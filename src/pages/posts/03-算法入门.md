<img/>  



### 好文和学习

```
public static int binarySearch(int x) {
	int l = 0, r = x, index = -1;
	while (l <= r) {
		int mid = l + (r-l)/2;
		if ((long)mid * mid <= x) {
			index = mid;
			l = mid + 1;
		} else {
			r = mid - 1;
		}
	}
	return index;
}

// 牛顿迭代
```



```
// 线性
```

```
// 两数之和等于目标值
public static void main(String[] args) {
		System.out.println(Arrays.toString(soulution(new int[]{1,2,3,4,5,6}, 10)));
}

public static int[] solution(int[] nums, int target) {
		for(int i=0; i<nums.length; i++) {
				for(int j=1; j<nums.length; j++) {
						if(nums[i] + nums[j] == target) {
								return new int[]{i,j};
						}
				}
		}
		return new int[0];
}
```



// 斐波那契数列第N位

```
# 暴力递归
# O(2^N) O(N) 
public static int recursive(int num) {
		if(num == 0) {
				return 0;
		}
		if(num == 1) {
				return 1;
		}
		return recursive(num-1)+recursive(num-2);
}

// 去重递归
public static int recurse1(int[] arr,int num) {
		if(num == 0) {
				return 0;
		}
		if(num == 1) {
				return 1;
		}
		if(arr[num] != 0) {
				return arr[num];
		}
		arr[num] = recurse1(arr, num-1)+recurse1(arr, num-2);
		return arr[num];
}

// 双指针迭代
# O(N) O(1)
public static int iteratal(int num) {
		if(num == 0){
				return 0;
		}
		if(num == 1){
				return 1;
		}
		int low = 0, high = 1;
		for(int i=2; i<=num; i++){
				int sum = low + high;
				low = high;
				high = sum;
		}
		return high;
}
```

 



// 排列硬币- 三种解法（暴力迭代/二分查找/牛顿迭代）

```
public static int arrangeCoins(int n) {
		for(int i=1; i <= n; i++) {
				n = n -i;
				if(n <= i) {
						return i;
				}
		}
		return 0;
}


```

// 环形链（遍历/快慢指针）







// 二叉树中序遍历（以下代码可在在线编译器直接运行）

```
class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode() {}
        TreeNode(int val) { this.val = val; }
        TreeNode(int val, TreeNode left, TreeNode right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }

public class Main {
    
    
    public static void main(String[] args) {
        TreeNode node4 = new TreeNode(4, null, null);
        TreeNode node3 = new TreeNode(3, null, node4);
        TreeNode node2 = new TreeNode(2, null, null);
        TreeNode node1 = new TreeNode(1, node2, node3);
        
        midOrder(node1);
    }
    
    public static void midOrder(TreeNode root) {
        if(root == null) {
            return;
        }
        midOrder(root.left);
        System.out.println(root.val);
        midOrder(root.right);
    }
}
```



```
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

public class Main {
    
    
	public static void main(String[] args) {
	    TreeNode node7 = new TreeNode(7, null, null);
	    TreeNode node6 = new TreeNode(6, null, null);
	    TreeNode node5 = new TreeNode(5, node6, null);
	    TreeNode node4 = new TreeNode(4, null, null);
	    TreeNode node3 = new TreeNode(3, node7, node5);
	    TreeNode node2 = new TreeNode(2, node4, null);
	    TreeNode node1 = new TreeNode(1, node2, node3);
	    
	    preOrder(node1);
	   // System.out.println(node1.val);
	}
	
	// 前序遍历
	public static void preOrder(TreeNode root) {
        if(root == null) {
            return;
        }
        System.out.println(root.val);
        preOrder(root.left);
        preOrder(root.right);
    }
}

```

**[预测赢家]**

```
// 动态规划 ， maxScore1(arr, l+1, r)存储到 [i+1][l] [i][j-1] dp数组
// 动态规划的重点就是找到这个dp数组

// 原本是二维数组，为了降低空间复杂度，作者找到i与j的关系，进行了简化
// 初始化
static boolean dp(int[] arr) {
	 int length = arr.length;
	 int[] dp = new int[length];
	 for(int i =0; i<length; i++) {
	 		dp[i] = arr[i];
	 }
	 for(int i =length-2; i>=0; i--){
	 		for(int j=i+1; j<length; j++){
	 				dp[j] = Math.max(arr[i] - dp[j], arr[j] - dp[j-1]);
	 		}
	 }
	 return dp[length - 1] >=0;
}
// 偶数位数组返回true
// 奇数位数组返回false
```

